### day17  mysql覆盖索引是什么？讲一下索引的最左前缀匹配原则。

   



### day24   简述TCP三次握手、四次挥手的流程？和其原因。

  TCP(Transmission Control Protocol) 是一种面向连接的协议，为了保证数据传输的可靠性，所以使用三次握手，四次挥手的过程。

**三次握手的过程**

> ​      1.第一次握手：客户端向服务器发送SYN报文，请求建立连接，其中包含一个随机生成的序列号*seq=x*。
>
> ​	  2.第二次握手：服务器收到客户端的SYN报文，向客户端发送SYN+ACK报文，其中包含一个随机生成的序列号seq=y和一个确认的序列号ack=x+1，表示可以建立连接，并准备好接受数据。
>
> ​      3.第三次握手：客户端收到服务器的SYN+ACK报文，向服务器发送ACK报文，其中包含一个确认的序列号ack=y+1，并且自己的序列号seq=x+1，表示连接已经建立。
>
> #####  三次挥手的目的是：为了确认双方的收发能力和同步初始序列号。
>
>    防止服务端开启一些无用的连接增加服务端的开销。
>
>    防止重复连接造成的连接错误。

**四次握手的过程**

  1.客户端向服务器发送FIN

​      当客户端不需要数据传输的时候，会向服务器发送一个FIN数据包，请求关闭连接。

  2.服务器回复ACK确认

​      服务器接收到FIN包之后回复ACK数据包，表示同意关闭连接，但可能还有数据要传输，不会立即关闭。

  3.服务器发送FIN

​      当服务器也没有数据要传输时，会向客户端发送一个FIN数据包，表示也准备好关闭连接。

  4.客户端发送ACK确认

​      客户端收到FIN包后回复ACK数据包，表示收到关闭请求，此时客户端处于 TIME-WAIT 状态，等待 2MSL(最大报文存活时间)后，若没有收到数据则说明服务端已关闭，自己也可以关闭连接。

**四次挥手目的是：确保数据都能传输完成并正常关闭连接，任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，再发出连接释放通知，对方确认后就完全关闭了TCP连接。**

 

------

 

# Java基础

### 1.JDK 和 JRE 和 JVM 分别是什么？有什么区别？

**官方解析**：

1.  JDK (Java Developmet Kit) : JDK 是 **JAVA 开发工具包**，包含了编写、变异、调试和运行 JAVA 程序       所需的所有工具和组件，比如编译器 (javac) 、Java API 、调试工具等。JDK 是针对 Java 开发人员的，它包含了 **JRE** ，还有编译器和其他工具，可以用来编写和调试 JAVA 程序。
2. JRE (Java Runtime Environmet): JRE 是 **Java 运行时环境**，包括 **Java 虚拟机（JVM) 和 Java 标准类库（Java API)** 。JRE 是针对 java 应用程序的，它**提供了在计算机上运行 Java 应用程序所需的最小环境。**
3. JVM (Java Virtual Mchine) ： **Java虚拟机**，是Java程序运行的环境。JVM 负责将 Java 代码，解释或编译为本地机器代码，并在运行时提供必要的环境支持，比如内存管理、垃圾回收、安全性等。主要作用是**将 Java 代码转换为可以在计算机上运行的机器码，并负责程序的执行。**

综上三者区别如下：

- **JDK** **是** **Java** **开发⼯具包**，包括了编译器、Java API、调试⼯具等，⽤于开发 Java 应⽤程

序。

- **JRE** **是** **Java** **运⾏时环境**，包括了 Java 虚拟机和 Java 标准类库，⽤于在计算机上运⾏

Java 应⽤程序。

- **JVM** **是** **Java** **虚拟机**，是 Java 程序运⾏的环境，负责将 Java 代码转换为可以在计算机上运⾏的机器码，并提供必要的环境⽀持。



**个人理解：**

- Java 虚拟机是运行 java 字节码的虚拟机 ， 针对不同的系统有特定的实现 （windows、linux、mac），目的是使用相同的字节码，使给的结果统一。字节码和不同系统的 JVM 实现是 Java 语⾔“⼀次编译，到处运⾏”的关键所在。
- JVM 并不是只有一种，不同的公司、组织或个人只要满足 JVM 规范，都可以开发属于自己的 JVM

  **java程序如何在计算机上运行：**

   1.编写Java源代码；--------需要⽤到JDK,**Java Development KitJava** (Java开发⼯具包)

   2.将Java源代码编译成字节码；---------需要⽤到JAVA开发⼯具包中的编译器（javac.exe⽣产.class文      	件

   3.Java虚拟机（JVM）将字节码转换成机器码；-------需要⽤到 **Java Virtual Machine** (Java虚拟机)

   4.操作系统执⾏机器码，完成程序的运⾏。---------需要⽤到Java Runtime Environment (Java运⾏环	境)。

**Java**开发⼯具包 **=Java** **运⾏环境**+Java **开发⼯具**

**Java** **运⾏环境**=Java**虚拟机**+Java**核⼼类库**

![image-20230601214858634](D:\笔记Md\image-20230601214858634.png)





------



### 2、什么是字节码？ 采用字节码最大的好处是什么？

**官方解析：**

​	字节码是 Java 程序编译后的中间代码， 是一种可移植的二进制代码，可以在任何支持 Java 虚拟机的平台上运行。字节码通过将 Java 源代码编译为字节码指令序列，使得 JAVA 程序可以跨平台运行。

**字节码采用中间代码的形式，相比于直接将程序编译为特定平台上的机械码，有以下几个好处：**

1. **可移植性**：由于字节码是中间代码，所以可以在任何⽀持 JVM 的平台上运⾏，使得 Java程序具有很好的可移植性。这也是 Java 跨平台的重要特性之⼀。

2. **安全性**：由于字节码需要在 JVM 中运⾏，所以可以对字节码进⾏安全检查，以确保程序不会对系统造成威胁。

3. **性能**：由于字节码是⼀种紧凑的⼆进制格式，相⽐于直接编译为机器码，可以更快地加载和传输，同时也可以在运⾏时进⾏动态优化，提⾼程序的执⾏效率。

4. **可读性**：相⽐于直接编译为机器码，字节码具有更好的可读性，可以⽅便地进⾏反汇编和调试。



​		因此，采⽤字节码作为中间代码的最⼤好处是提⾼了 Java 程序的可移植性、安全性、性能和

可读性。这也是 Java 跨平台和安全性等特性的基础。



**个人理解：**

![image-20230417224853842](D:\笔记Md\picture\image-20230417224853842.png)





------

### 3、Java  和  C++ 、 Go 语言的区别，各种的优缺点？

**JAVA**

 **优点：**

- [ ] ​	简单易学，代码可读性强
- [ ] ​	跨平台，⼀次编写可以在多个操作系统上运⾏
- [ ] ​	⾯向对象，⽀持继承、多态等特性
- [ ] ​	丰富的类库，可以快速开发应⽤程序
- [ ] ​	⾃动内存管理，减少了内存泄漏的可能性

 **缺点:**

​	由于JVM的存在，运⾏速度相对较慢

​	对于实时性要求较⾼的场景，Java的表现可能不如C++和Go

**C++**

 **优点****：**

​	速度快，适合编写需要⾼性能的应⽤程序

​	应⽤⼴泛，特别是在游戏开发、操作系统和嵌⼊式系统开发⽅⾯

​	灵活性⾼，可以直接访问硬件和内存

 **缺点：**

​	学习难度较⾼，需要掌握指针、内存管理等底层知识

​	容易出现内存泄漏和指针错误等问题

​	编写代码过程中需要更多的⼿动管理，相⽐ Java 更容易出错

**Go:**

 **优点：**

​	⾼并发，天⽣⽀持协程，能够轻松编写⾼效的并发程序

​	简单易学，语法简洁，上⼿容易

​	静态类型语⾔，可以避免⼀些潜在的运⾏时错误

​	快速编译，可以快速构建和部署应⽤程序

 **缺点：**

​	缺乏丰富的类库，与 Java 和 C++ 相⽐有些不⾜

​	在⼀些性能要求极⾼的场景中可能不如 C++ 表现

​	语⾔本身还⽐较年轻，相关⽣态和⼯具还需要进⼀步完善



**使⽤场景：**

**JAVA**

​	适合开发企业级应⽤程序、后端服务等。

**C++**

​	适合开发需要⾼性能和⾼可靠性的应⽤程序，特别是在游戏开发、操作系统和嵌⼊式系统

​    开发⽅⾯。

**GO**

​	适合开发⾼并发的后端服务、微服务、容器化应⽤程序等.



当然，每种语⾔都有其独特的优势和适⽤场景，具体应根据项⽬需求和开发团队的技术背景来

选择合适的语⾔。

如果当⾯试官问你这个问题时，他们可能想要了解你对不同编程语⾔的了解和理解程度，以及

你是否能够根据不同的项⽬需求和特点选择合适的编程语⾔。

此外，⾯试官可能还想知道你是否有跨语⾔的经验和能⼒，以及你是否能够评估和解决跨语⾔

集成和兼容性问题。

最后，通过你的回答，⾯试官还可以了解你对软件开发⽣态系统的了解程度，以及你是否能够

在⾏业发展和趋势⽅⾯保持敏锐的洞察⼒。



------

### 4.String 、StringBuilder、StringBuffer区别？单线程大量操作字符串用哪个？

> **三者都是Java在用于操作字符串的类**
>
> String 是**不可变的字符序列**，每次对 String 进行修改时都会创建一个新的 String 对象，因此在大量操作字符串时，使用 String 会频繁的创建对象，导致性能较低。
>
> StringBuilder 和 StringBuffer 都是可变的字符序列，可以对其进行多次修改而不创建新的对象。两者的区别在于线程安全性，后者是线程安全的，前者是非线程安全的。因为 StringBuffer 的所有公共方法都是同步的，所有在多线程环境下使用可以保证线程安全，但是会降低性能。而 StringBuilder 没有同步方法，所以在单线程环境下使用 StringBuilder可以节省资源。
>
> 因此，在单线程环境下进行大量的字符串操作时，应该使用 StringBuilder，可以获得更好的性能。在多线程环境下，使用 StringBuffer 可以保证线程安全，但是会牺牲一定的性能。
>

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`

> 综上所述，**单线程大量操作字符串时应该使用 StringBuilder，而在多线程环境下应该使用 StringBuffer。**

StringBuffer 和 StringBuilder 都继承于 AbstractStringBUilder 类，也是使用字符串数组保存字符串，但没有使用 final 和 private 关键字修饰，还提供了很多修改字符串的方法 如 **append**、insert、indexOf、expandCapacity。

 

**String 类为什么是不可变的？**

- 保存字符串的数组被 `final` 修饰且为私有的，并且`String`这个类没有提供/暴露修改这个字符串的方法。
-  String 被 final 修饰 导致其不能被继承，进而避免了子类破坏 String 不可变。

java9之后，三者对实现改用 `byte`数组存储字符串。

```java
public final class String implements java.io.Serializable,Comparable<String>, CharSequence {
    // @Stable 注解表示变量最多被修改一次，称为“稳定的”。
    @Stable
    private final byte[] value;
}

abstract class AbstractStringBuilder implements Appendable, CharSequence {
    byte[] value;

}
```

新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，`byte` 占一个字节(8 位)，`char` 占用 2 个字节（16），`byte` 相较 `char` 节省一半的内存空间.



------

### 5.synchronized 偏向锁直接升级为重量级锁吗？重量级锁怎么实现？

synchronized 锁有四种状态：

**无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态**。当一个线程获得偏向锁后，如果另外一个线程尝试获取锁，则偏向锁会升级为轻量级锁。当多个线程竞争锁时，轻量级锁会升级为重量级锁，此时会使用操作系统的 mutex 来实现锁。因此， synchronized 偏向锁不会直接升级为重量级锁，而是会经过轻量级锁的阶段。

> 重量级锁是指在多线程竞争锁的情况下，使用操作系统的Mutex（互斥量）实现锁的机制。具体实现步骤如下：
>
> 1. 当一个线程请求锁时，如果持有锁的线程是同一个线程，那么这个线程直接获得锁，不需要竞争。
>
> 2. 如果持有锁的线程不是同一个线程，那么请求锁的线程就会进入阻塞状态，等待持有锁的线程释放锁。
>
> 3. 当持有锁的线程释放锁时，操作系统会通知阻塞的线程，让它们重新竞争锁。
>
> 4. 竞争成功的线程将获得锁，并执行临界区代码。
>
> 5. 当线程执行完临界区代码后，释放锁，操作系统通知阻塞的线程重新竞争锁。
>
> 6. 如果有多个线程竞争锁，那么操作系统会选择其中一个线程获得锁，并通知其他线程进入阻塞状态，等待下一次竞争。
>
> 重量级锁的实现需要操作系统的支持，因此相比于轻量级锁和偏向锁，它的性能更低，应该尽量避免使用。

------

### 6.Java 中的异常

当程序出现异常时，Java会抛出一个异常对象，Java 中的异常可以分为三类：

1. Checked Exception（受检异常）：这种异常在编译时就可以被检测出来，必须要在代码中进行处理或者声明抛出，否则编译不通过。这类异常主要是由程序的外部环境引起的，例如文件不存在、网络连接失败等。常见的 Checked Exception 包括 IOException、SQLException 等。
2. Unchecked Exception（非受检异常）：这种异常通常是由程序内部错误引起的，例如 NullPointerException、ArrayIndexOutOfBoundsException、IllegalArgumentException 等。这类异常不需要在代码中声明抛出，也可以不进行处理，但是如果不进行处理，程序会崩溃。
3. Error：这种异常通常是由 JVM 或者硬件引起的，例如OutOfMemoryError、StackOverflowError 等。这类异常也不需要在代码中声明抛出，也可以不进行处理，但是如果不进行处理，程序也会崩溃。

在 Java 中，异常处理通常包括 try-catch 语句和 throw 语句。try-catch 语句可以捕获异常并进行处理，而 throw 语句可以手动抛出异常。

Java中的异常处理机制可以有效地处理程序中的异常情况，使程序更加健壮和可靠。但是，在使用异常处理机制时，应该注意避免过度使用异常，以及避免在异常处理中对程序的性能产生不必要的影响。

------

### 7.JDK 动态代理 和 CGLIB 动态代理的区别？

**官方解析**：

JDK 动态代理和 CGLIB 动态代理都是 Java 中动态代理的两种实现⽅式，它们的区别主要在以下⼏个⽅⾯：



> - 实现⽅式：JDK 动态代理是通过反射实现的，⽽CGLIB动态代理是通过继承⽬标类来实现的。
> - ⽬标类限制：JDK 动态代理要求⽬标类必须要实现接⼝，⽽CGLIB动态代理则没有这个限制。
> - 性能：JDK 动态代理相对于 CGLIB 动态代理来说，因为实现⽅式不同，⽣成的代理类的效率会低⼀些。
> - 对象类型：JDK 动态代理只能代理实现了接⼝的类，CGLIB 通过继承实现，不能代理final 类。
> - 依赖库：JDK 动态代理是 Java ⾃带的库，不需要额外的依赖，⽽ CGLIB 动态代理需要依赖 cglib 库。



在使⽤动态代理时，可以根据需要和具体的场景选择合适的实现⽅式，JDK 动态代理适⽤于**接⼝代理**的场景，⽽ CGLIB 动态代理适⽤于**类代理**的场景。



**个人理解：**

JDK和CGLib动态代理区别

1、JDK动态代理具体实现原理：

> - 通过实现 InvocationHandler 接⼝创建⾃⼰的调⽤处理器；
> - 通过为 Proxy 类指定 ClassLoader 对象和⼀组 interface 来创建动态代理；
> - 通过反射机制获取动态代理类的构造函数，其唯⼀参数类型就是调⽤处理器接⼝类型；
> - 通过构造函数创建动态代理类实例，构造时调⽤处理器对象作为参数参⼊；

JDK 动态代理是⾯向接⼝的代理模式，如果被代理⽬标没有接⼝那么 Spring 也⽆能为⼒，Spring 通过 Java 的反射机制⽣产被代理接⼝的新的匿名实现类，重写了其中 AOP 的增强⽅法。



2、CGLib动态代理：

>   利⽤ ASM 开源包，对代理对象类的 class ⽂件加载进来，通过修改其字节码⽣成⼦类来处理。

3、两者对⽐：

> JDK 动态代理是⾯向接⼝的。
>
> CGLib 动态代理是通过字节码底层继承要代理类来实现，因此如果被代理类被 final 关键字所修饰，会失败。
>
> 如果要被代理的对象是个实现类，那么 Spring 会使⽤ JDK 动态代理来完成操作（Spirng 默认采⽤ JDK 动态代理实现机制）；
>
> 如果要被代理的对象不是个实现类，那么 Spring 会强制使⽤ CGLib 来实现动态代理。

![image-20230513124446188](D:\笔记Md\picture\image-20230513124446188.png)

------

------

### 8.Java 中 final 关键字的作用？

**官方解析**

在 Java 中，final 关键字用于表示一个**不可变的常量**或者一个**不可变的变量**。

final可以修饰类、方法和变量，作用如下：

> 1. final 修饰类，表示该类不能被继承。final 类中的方法默认都是 final 的，不能被子类重写。
> 2. final 修饰方法，表示该方法不能被子类重写。
> 3. final 修饰变量，表示该变量只能被赋值一次。final 修饰的变量必须在声明时或者构造函数中初始化，且不能再被修改。常用于定义常量。

另外，是用 final 修饰的变量在编译时就已经确定了值，因此在运行时访问时比   非 final 变量更快。



使⽤ final 关键字可以带来⼀些好处，例如：

> 1. 安全性：将变量声明为 final 可以防⽌它被改变，从⽽提⾼安全性。
>
> 2. 可读性：将常量声明为 final 可以提⾼代码的可读性，因为常量的值不会被修改。
>
> 3. 优化：final 变量在编译时被转换成常量，这可以提⾼程序的性能。

总之，final 关键字在 Java 中⾮常有⽤，可以提⾼程序的安全性、可读性和性能。



**个人理解：**

1. 定义常量：
2. 防止方法被重写
3. 防止类被继承
4. 确保对象引用不可变：在对象引⽤声明前加上 final 关键字，可以确保该引⽤指向的对象不能被改变，但是该对象的内容可以被改变。例如，final MyClass obj = new MyClass();将 obj 声明为⼀个不可变引⽤，指向⼀个可变的 MyClass 对象。
5. 需要注意的是，final 关键字不同于 static 关键字，final 关键字⽤于定义常量或限制重写或继承等操作，⽽ static 关键字⽤于定义静态变量或⽅法，表示这些成员属于类，⽽不是属于对象。

------

### 9.Java 中 hashCode 和 equals 方法是什么？ 它们和 == 各有什么区别 ？

在 Java 中，hashCode 和 equals方法都是 Object 类的方法，作用方便如下：

-  hashCode 方法返回对象的哈希码，用于支持基于哈希表的集合，如HashSet、HashMap等。如果两个对象的 equals 方法返回 true ，则它们的 hashCode 方法必须返回相同的价值，反之则不需要。
- equals 用于对比对象是否相等。默认情况下，equals 方法使用的是 == 操作符，即只有两个对象引用指向同一个对象时才会返回true但是，⼤部分情况下，我们需要重写equals ⽅法来实现⾃⼰定义的相等规则。

![image-20230513133222621](D:\笔记Md\picture\image-20230513133222621.png)

总结：

> - 如果两个对象equals相同,hashCode⼀定相同
> - 如果两个对象equals不同,hashCode不⼀定不同
> - 如果两个对象的hashCode相同，它们的equals并不⼀定相同
> - 如果两个对象的hashCode不相同，它们的equals⼀定不相同



所有⽐较是否相等时，都是⽤equals ，并且在对常量相⽐较时，把常量写在前⾯，因为使⽤object的 equals object可能为null 则空指针 在阿⾥的代码规范中只使⽤equals ，阿⾥插件默认会识别，并可以快速修改，推荐安装阿⾥插件来排 查⽼代码使⽤“==”，替换成equals



- 对基本数据类型来说，== 比较的是值



- 对引用数据类型, 比较的是对象的内存地址



------

### 10. 什么是反射机制 ？ 说说其优缺点和应用场景？

​		Java 反射机制是指在运⾏时动态地获取类的信息、创建对象以及调⽤对象的属性和⽅法的机制。Java 反射机制提供了运⾏时检查 Java 类型信息的能⼒，让 Java 程序可以通过程序获取其本身的信息。



反射就是 Reflection，Java 的反射是指程序在运行期可以拿到一个对象的所有信息。正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例

> ​	->在运行时判断任意一个对象所属的类
>
> ​	->在运行时构造任意一个类的对象
>
> ​	->在运行时判断任意一个类所具有的成员变量和方法
>
> ​	->在运行时获取泛型信息
>
> ​	->在运行时调用任意一个对象的成员变量和方法
>
> ​	->在运行时处理注解
>
> ​	->生成动态代理



优点：

可以实现动态创建对象和编译，体现出很大的灵活性

缺点：

对性能有影响。 使用反射基本上是一种解释操作，我们可以告诉 JVM ，我们希望做什么并且它满足我们的要求。这类操作总是慢与直接执行相同的操作。



Java的反射机制是指在运⾏时获得类的信息，创建类的对象，调⽤其中的⽅法和属性。 



反射机制的优点：

​	可以动态的获取类信息。

​	可以动态的创建类对象。

​	可以动态的调⽤类对象的⽅法以及属性。



反射机制的缺点：

​	不安全，反射能够获取所有类对象，包括私有的，破坏了程序的封装性。

​	效率低，反射的效率较低。



应⽤场景：

​	动态代理，因为不确定需要代理的类，所以需要通过反射动态的获取RPC 框架，RPC 框架就是动态的⽣成类对象，然后调⽤⽅法的。



------

### 11. Java 访问修饰符de区别？

​		在 Java 中，访问修饰符指的是控制类、接⼝、⽅法、属性等成员的访问范围。Java 提供了四种访问修饰符，分别为 **public、private、protected 和默认（⽆修饰符）**。

> - public：可以被任何类或对象访问。
> - private：只能被定义该成员的类访问，其他类⽆法访问。
> - protected：可以被当前类、⼦类和同⼀个包中的类访问。
> - 默认（⽆修饰符）：可以被同⼀个包中的类访问。



下⾯简要总结⼀下各个访问修饰符的特点：

> - ​	public 可以被任何类或对象访问，因此其访问范围最⼤，但也可能会存在安全问题。
> - ​	private 限制了访问范围，可以有效保护数据的安全，但是可能会增加代码的耦合度。
> - ​	protected 提供了⼀种在继承中使⽤的访问控制⽅式，但是可能会导致模块间的耦合。
> - ​	默认（⽆修饰符）访问范围⽐ protected 更⼩，只能被同⼀个包中的类访问，可以减⼩模块间的耦合。



​		访问修饰符的选择需要根据具体情况来考虑，不能⼀概⽽论。通常情况下，应该尽可能地将成员设置为 private，只在需要的情况下使⽤ public 或 protected。

需要注意的是，在同⼀个类中，成员可以直接访问其他成员，⽆论其访问修饰符是什么。

![image-20230513203247336](D:\笔记Md\picture\image-20230513203247336.png)

------

### 12. 什么是 Java 内部类？ 内部类的分类有哪些？内部类有哪些应用场景和优点？

**官方解析：**

​	内部类是定义在另⼀个类中的类。Java 中内部类主要分为**成员内部类、静态内部类、局部内部类和匿名内部类**四种。

> 1. **成员内部类**：定义在另⼀个类的内部，并且与其它成员变量和⽅法平级，可以访问外部类的所有成员变量和⽅法。使⽤⽅式：Outer.Inner inner = new Outer().new Inner()。
>
> 2. **静态内部类**：定义在另⼀个类的内部，但是要⽤ **static** 修饰。只能访问外部类的静态成员变量和⽅法。使⽤⽅式：
>
>    Outer.Inner inner = new Outer.Inner()。
>
> 3. **局部内部类**：定义在**⽅法**中，作⽤域仅限于⽅法内部。与局部变量类似，不能使⽤访问控制符修饰。使⽤⽅式：在⽅法中直接实化。
>
> 4. **匿名内部类**：没有名字的内部类。使⽤⽅式：
>
>    new 接⼝或者抽象类() { } 或 new ⽗类() {}。



> 内部类的优点：
>
> ​	可以访问外部类的私有成员变量和⽅法。
>
> ​	可以隐藏实现细节。
>
> ​	便于编写和维护，提⾼代码的可读性和可维护性。
>
> ​	内部类可以很好地解决Java中单继承的问题。



> 内部类的应⽤场景：
>
> ​	需要访问外部类的私有成员变量和⽅法。
>
> ​	需要定义⼀个回调函数或者监听器。
>
> ​	需要实现多重继承。
>
> ​	需要对外部类进⾏扩展。



![image-20230513204244948](D:\笔记Md\picture\image-20230513204244948.png)



![image-20230513204646560](D:\笔记Md\picture\image-20230513204646560.png)



------

### 13. 成员变量和局部变量的区别

> - 语法形式：成员变量属于类，可被public、private、static修饰；局部变量在代码块或方法中定义的变量或是说就是方法的参数，不可被权限修饰符修饰，但可被final修饰。
> - 存储方式：成员变量若使用static 修饰，则该变量属于类，否则属于实例的。对象存储在堆内存中，局部变量存储在栈内存中。
> - 生存时间：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。
> - 默认值：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。

``` java
public class VariableExample {

    // 成员变量
    private String name;
    private int age;

    // 方法中的局部变量
    public void method() {
        int num1 = 10; // 栈中分配的局部变量
        String str = "Hello, world!"; // 栈中分配的局部变量
        System.out.println(num1);
        System.out.println(str);
    }

    // 带参数的方法中的局部变量
    public void method2(int num2) {
        int sum = num2 + 10; // 栈中分配的局部变量
        System.out.println(sum);
    }

    // 构造方法中的局部变量
    public VariableExample(String name, int age) {
        this.name = name; // 对成员变量进行赋值
        this.age = age; // 对成员变量进行赋值
        int num3 = 20; // 栈中分配的局部变量
        String str2 = "Hello, " + this.name + "!"; // 栈中分配的局部变量
        System.out.println(num3);
        System.out.println(str2);
    }
}


```

------

### 14. 重载和重写的区别

> 重载就是同样的一个方法能够1根据输入的数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，需要覆盖父类的方法

- **重载**： 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同。可以理解为同一个类中多个同名的方法根据不同的传参来执行不同的逻辑处理。

- **重写：**重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

  1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
  2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
  3. 构造方法无法被重写

  



------

### 15. Object 类常见的方法

``` java
/**
 * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。
 */
public final native Class<?> getClass()
/**
 * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。
 */
public native int hashCode()
/**
 * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。
 */
public boolean equals(Object obj)
/**
 * naitive 方法，用于创建并返回当前对象的一份拷贝。
 */
protected native Object clone() throws CloneNotSupportedException
/**
 * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。
 */
public String toString()
/**
 * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
 */
public final native void notify()
/**
 * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
 */
public final native void notifyAll()
/**
 * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。
 */
public final native void wait(long timeout) throws InterruptedException
/**
 * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。
 */
public final void wait(long timeout, int nanos) throws InterruptedException
/**
 * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
 */
public final void wait() throws InterruptedException
/**
 * 实例被垃圾回收器回收的时候触发的操作
 */
protected void finalize() throws Throwable { }

```









------

------

# Redis

### redis的内存淘汰机制

- noeviction（默认）：当redis内存达到最大限制时，**不再进行淘汰操作**，此时所有的写操作请求都会被拒绝。适用于数据访问频率较低且数据量较大的场景。
- allkeys-lru：淘汰最近最少使用的键值对，即长时间没用被访问的数据。适用于数据访问频率比较高的场景。
- allkeys-random：随机淘汰键值对。适用于数据访问频率比较平均的场景。
- volatile-lru：淘汰最近最少使用的设置过期时间的键值对。适用于需要定期清理过期数据的场景。
- volatile-random：....... ，场景同上。
- volatile-ttl：淘汰剩余时间最少的键值对。适用于需要及时清理过期数据的场景。
- volatile-lfu：淘汰剩余空间最少的键值对，适用于需要及时清理过期数据且不希望删除历史数据的场景。



LRU （Least Recently Used）：最近最少使用，用到前时间减去最后一次使用时间，这个值越大就优先淘汰该值

LFU (Least Fruquently Used) ： 最少频率使用，会统计每个key的访问频率，值越小的优先淘汰



**使用建议**：

> 1. 优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。
>
> 2. 如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。
>
> 3. 如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。
>
> 4. 如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。





------

### Redis 有什么用，为什么要使用Redis/为什么要用缓存？













### Redis 除了缓存还能做什么？











### Redis 常用的数据结构











### 使用 Redis 统计网站 UV 怎么做？













### 使用 Redis 实现一个排行榜怎么做？











### 什么是 Redis 单线程模型？











### Redis 给缓存数据设置过期时间有啥用？











### Redis 是如何判断数据是否过期的？









### 过期的数据的删除策略了解吗？











### 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？











### 什么是 RDB 持久化？











### 什么是 AOF 持久化？











### 如何使用 Redis 事务？









### Redis 事务支持原子性吗？











### Redis 事务有什么缺陷？











### 如何解决该缺陷？











### 什么是 bigkey？ 有什么危害？



### 如何发现？





### 如何避免大量key集中过期？











### 什么是 Redis 内存碎片？为什么会有？













------



# 操作系统



### 什么是进程和线程？他们有什么区别和联系？

**官方解析**

- 在操作系统中，**进程是指一个正在执行中的程序，而线程是进程的一部分**，是一个程序中执行的代码片段
- **进程是操作系统资源分配的最小单位**，**一个进程至少包括一个线程**，进程拥有自己的内存空间、文件句柄、环境变量等系统资源。进程间相互独立，互不干扰，每个进程都拥有自己的空间地址。进程通信需要通过进程间通信机制 （IPC) 实现。
- **进程和线程的区别和联系如下：**
  1.   资源分配：进程拥有自己的内存空间等系统资源，而线程共享进程的资源，可访问所属进程的全部资源。
  2.   独立性：进程之间相互独立，互不干扰，而线程是进程的一部分，线程之间共享进程的资源。同一进程的线程可能相互影响。
  3.   调度：进程间调度的开销比线程大，线程的调度开销小，可以并发实现。未引入线程的 os 中，进程是     调度和分派的基本单位；进入线程的 os 中，线程是调度和分派的基本单位，但是线程不能脱离进程运行。
  4.   并发性：多个进程间相互独立，多个线程可以并发执行。
  5.   同步：进程间通信需要通过  IPC 机制，线程间同步可以通过共享内存，信号量等机制。

​		**在实际开发中，多线程应用更加常见，因为线程的开销小，执行效率高，适用于需要并发执行的场景。但需要注意线程安全问题。而多进程应用通常更加稳定，但开销较大，适用于需要独立运行的场景。**



------



###  线程有几种状态

1. 新建状态(New):当一个线程对象被创建时，它就处于新建状态。此时，线程还没有启动，也没有分配到系统资源。
2. 就绪状态(Runnable):当调用线程的start()方法后，如果该线程没有被阻塞，那么它就会进入就绪状态。此时，线程已经分配到了CPU时间片，并且已经初始化了执行状态，等待系统调度执行。
3. 运行状态(Running):当线程被调度执行后，它就处于运行状态。此时，线程正在执行它的run()方法中的代码。
4. 阻塞状态(Blocked):当线程试图获取一个已经被其他线程占用的锁或者等待一个事件发生时，它就会进入阻塞状态。此时，线程暂时停止执行，直到获取到锁或者等待的事件发生。
5. 等待状态(Waiting):当线程调用wait()、join()或sleep()等方法时，它就会进入等待状态。此时，线程暂停执行，直到被其他线程唤醒。
6. 终止状态(Terminated):当线程执行完它的run()方法后，或者出现异常导致线程正常退出时，它就会进入终止状态。此时，线程已经完成了它的任务，不再执行任何操作。





------

### 进程间的通信方式？ 管道模型的分类？

最简单的方式就是**管道**，管道分为「匿名管道」和「命名管道」。

- **匿名管道**顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「`|`」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失。
- **命名管道**突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，那么毫无关系的进程就可以通过这个设备文件进行通信。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则。

**消息队列**克服了管道通信的数据是无格式的字节流的问题，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。

**共享内存**可以解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，**享有最快的进程间通信方式之名**。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。

那么，就需要**信号量**来保护共享资源，以确保任何时刻只能有一个进程访问共享资源，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。

与信号量名字很相似的叫**信号**，它俩名字虽然相似，但功能一点儿都不一样。信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 `SIGKILL` 和 `SIGSTOP`，这是为了方便我们能在任何时候结束或停止某个进程。

前面说到的通信机制，都是工作于同一台主机，如果要与不同主机的进程间通信，那么就需要 **Socket 通信**了。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。





------

### 内核态和用户态的区别？内核态的底层操作有什么？为什么要分为两个不同的态？

内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于权限和可执行的操作：

1. 内核态（Kernel Mode）：在内核态下，CPU 可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。
2. 用户态（User Mode）：在用户态下，CPU 只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。

内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。

分为内核态和用户态的原因主要有以下几点：

1. 安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。
2. 稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。
3. 隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。

内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。

------

### HTTPS的执行流程

(Hypertext Transfer Protocol Secure) 是一种安全的Web传输协议，它使用 SSL/TLS 协议来保护数传输的安全性和隐私性。执行流程如下：

1. 客户端向服务器发送请求：
2. 服务端返回响应：
3. 建立 SSL/TLS 连接：
4. 进行加密和解密：
5. 响应处理：

------

### 实现多线程有几种方法

- 继承 Thread 类并实现 run（）方法：

  ``` java
  public class MyThread extends Thread {
      @Override
      public void run() {
          // 线程执行的逻辑
      }
  }
  // 在主线程中创建并启动MyThread对象
  MyThread myThread = new MyThread();
  myThread.start();
  ```

  

- 实现Runnable 接口并实现 run（）方法：需要注意的是，在Java中，只有实现了Runnable接口的对象才能作为Thread的构造参数。

  ``` java
  public class MyRunnable implements Runnable {
      @Override
      public void run() {
          // 线程执行的逻辑
      }
  }
  // 在主线程中创建并启动MyRunnable对象的线程实例
  MyRunnable myRunnable = new MyRunnable();
  Thread thread = new Thread(myRunnable);
  thread.start();
  ```

  

- 实现 Callable 接口并实现 call（） 方法： 与Runnable接口类似，Callable接口也可以用来实现多线程。需要注意的是，Callable接口返回的结果可以是任何类型，包括异常类型。如果需要抛出异常，可以使用throws关键字在方法声明中指定。

  ``` java
  public class MyCallable implements Callable<Integer> {
      @Override
      public Integer call() throws Exception {
          // 线程执行的逻辑，返回结果为整数类型
          return result;
      }
  }
  // 在主线程中调用MyCallable对象的call()方法，并获取返回值(使用FutureTask类)
  FutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());
  Integer result = futureTask.get();
  // 或者直接使用ExecutorService.submit()方法提交任务并获取返回值(使用Future类)
  ```

  ------
  
  ### 什么是上下文切换
  
  ​		上下文切换是操作系统在**进行多任务处理时**，由于**进程或线程的切换而进行的一种机制**。在某个进程或线程正在执行时，当操作系统需要将其**暂停**下来，**转而执行另一个进程或线程**时，操作系统需要先**保存当前进程或线程的状态**（称为上下文），包括 CPU 寄存器、程序计数器等信息并将其存储到内存中；然后再通过调度算法选择另一个进程或线程，并从前一个进程或线程保存的上下文恢复后，继续执行新的进程或线程。
  
  ​		上下文切换是操作系统必须进行的一种重要机制，因为在现代操作系统中，同时可能有多个进程或线程在进行运算，这些进程或线程需要共享 CPU 等系统资源。而上下文切换使得不同的进程或线程可以交替执行，从而提高系统资源的利用效率和多任务处理能力。然而，上下文切换本身是会带来一定开销的，比如需要保存和恢复进程或线程的状态等，因此在设计系统时需要充分考虑和优化上下文切换的成本。

------

### sleep() 和 wati() 方法的区别和共同点

sleep() 和 wait() 方法是 Java 多线程编程中常用的两个方法，它们既有相同点，也有区别点。

共同点： 

1. 既然两个方法都是**用于线程间的交互**，都可以**让线程暂停执行**。 

2. 都是 Object 类的方法，即 Java 中所有类都会有 wait() 和 notify()/notifyAll() 方法，因为其本质都是 Object 类的一部分。

区别点：

1. wait() 和 notify()/notifyAll() 方法是用于线程的同步和互斥，而 sleep() 方法是用于线程的阻塞，阻塞指的是暂时停止执行，而不是释放锁。每个对象都有一个锁，wait() 方法会释放锁并挂起线程，而 sleep() 方法则不会释放锁。

2. wait() 方法需要释放锁，同时还需要等待其他线程调用 notify() 或 notifyAll() 方法唤醒它。而 sleep() 方法只是暂停线程的执行时间段，时间到之后线程就会自动恢复执行。

3. wait() 和 notify()/notifyAll() 方法只能用在同步块或同步方法中，而 sleep() 方法可以在任何地方使用。

4. wait() 方法可以通过指定等待时间来自动唤醒，而 sleep() 方法可以通过 interrupt() 方法打断线程。

综上所述，两者的作用有相似之处，但各自适合不同的应用场景。通常情况下，当线程需要等待一个条件达成时应该使用 wait() 和 notify()，而当线程需要暂停一段时间再执行时可使用 sleep()。











------



# MySql



### 1. 什么是MySQL 事务？讲解一下 ACID 特性？



​		数据库事务是指数据库管理系统（DBMS）中的⼀个操作序列，这些操作必须作为⼀个不可分割的单元执⾏，即要**么全部执⾏成功，要么全部失败回滚**。事务通常涉及到对数据库中的数据进⾏读写操作。事务的 **ACID** 特性指四个关键特征：原⼦性（Atomicity）、⼀致性（Consistency）、隔离性（Isolation）和持久性（Durability）。



> 1.**原⼦性**（Atomicity）：事务是⼀个原⼦操作，要么全部提交，要么全部回滚。当⼀个事务执⾏期间发⽣故障，操作系统会⾃动将其回滚到事务执⾏之前的状态，保证数据的⼀致性。
>
> 原⼦性是指事务是**⼀个不可再分割的⼯作单元**，事务中的操作要么都发⽣，要么都不发⽣。可采⽤“A向B转账”这个例⼦来说明解释。
>
> 在 DBMS 中，默认情况下⼀条 SQL 就是⼀个单独事务，事务是⾃动提交的。只有显式的使⽤start transaction 开启⼀个事务，才能将⼀个代码块放在事务中执⾏。
>
> 
>
> 2.**⼀致性**（Consistency）：事务执⾏结束后，数据必须保持⼀致性状态。在事务执⾏期间，数据库中的数据可以处于中间状态，但在事务完成时必须保证数据的⼀致性。
>
> **⼀致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。**这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的⼀致性。
>
> 如 A 给 B 转账，不论转账的事务操作是否成功，其两者的存款总额不变（这是业务逻辑的⼀致性，⾄于数据库关系约束的完整性就更好理解了）。
>
> 
>
> 3.**隔离性**（Isolation）：数据库系统必须保证事务之间相互隔离，不会互相⼲扰。隔离级别不同，会影响到事务的并发性和数据⼀致性，⽐如出现脏读、不可重复读、幻读等问题。
>
> 
>
> **多个事务并发访问时，事务之间是隔离的**，⼀个事务不应该影响其它事务运⾏效果。
>
> 在并发环境中，**当不同的事务同时操纵相同的数据**时，每个事务都有**各⾃的完整数据空间**。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另⼀事务修改它之前的状态，要么是另⼀事务修改它之后的状态，**事务不会查看到中间状态的数据**。
>
> 事务最复杂问题都是由事务隔离性引起的。完全的隔离性是不现实的，完全的隔离性要求数据库同⼀时间只执⾏⼀条事务，这样会严重影响性能。
>
> 
>
> **有四种隔离级别：**
>
> - ​	第⼀种隔离级别：**Read uncommitted(读未提交)**解决了更新丢失，但还是可能会出现**脏读**
> - ​	第⼆种隔离级别：**Read committed(读提交)**解决了更新丢失和脏读问题
> - ​	第三种隔离级别：**Repeatable read(可重复读取 默认)**解决了更新丢失、脏读、不可重复读、但是还会出现幻读
> - ​	第四种隔离级别：**Serializable(可序化)**解决了更新丢失、脏读、不可重复读、幻读(虚读)
>
> **脏读**：一个事务读到另一个事务还没提交的数据
>
> **不可重复读**：一个事务先后读取到了同一条记录，但两次读取的数据不同
>
> **幻读**：一个事务按照条件查询时，没有对应的数据好，但是在插入时发现该行有数据
>
> 
>
> 4.**持久性**（Durability）：⼀旦事务提交，其所做的修改必须永久保存到数据库中。即使系统发⽣故障或宕机，数据也能够保持不变
>
> ​		这是最好理解的⼀个特性：**持久性**，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将⼀直保持）
>
> 



​		ACID 特性是保证事务正确性和数据⼀致性的重要⼿段。在设计数据库应⽤程序时，应该根据具体的业务需求和数据安全性要求，选择合适的隔离级别和事务提交策略，保证事务的可靠性和数据的⼀致性。



**InnoDB中：**

1. 通过 undo log ⽀持事务回滚、当前读（多版本查询）
2. 通过 redo log 实现持久性
3. 通过两阶段提交实现⼀致性
4. 通过当前读、锁实现隔离性



------

### 2. MySQL 日志有？ binlog、redolog、undolog分别有什么作用？有什么区别？

MySQL 是⼀款流⾏的关系型数据库，其⽇志是其关键功能之⼀。MySQL 包括三种类型的⽇志，分别是 binlog、redolog 和 undolog，它们分别有不同的作⽤和特点。

> - binlog ，binlog（Binary log）是 MySQL 中的⼆进制⽇志⽂件，⽤于记录 MySQL 服务器上的所有更新和修改操作。它可以记录所有的 DDL（Data Definition Language）和 DML（Data Modification Language）操作，包括对表结构的更改、数据的插⼊、修改、删除等等。binlog是在事务提交后⽣成的，因此可以⽤于恢复数据库。
>
> 
>
> - redolog ，redolog（Redo log）⽤于恢复数据，保证数据的⼀致性和持久性。当 MySQL发⽣修改时，redolog 会将这些操作记录下来，并写⼊磁盘。这样，当 MySQL 发⽣宕机或崩溃时，通过重放 redolog 就可以恢复数据。
>
> ![image-20230520101929501](D:\笔记Md\picture\image-20230520101929501.png)
>
> 
>
> - undolog，undolog（Undo log）⽤于回滚操作。当 MySQL 发⽣事务回滚时，undolog会记录这些操作并将其写⼊磁盘。这样，MySQL 需要回滚时，通过重放 undolog 就可以回滚事务。
>
> ![image-20230520102047076](D:\笔记Md\picture\image-20230520102047076.png)
>
> 

区别：

> - binlog 和 redolog 都是 MySQL 中的⼆进制⽇志，但是它们的作⽤和实现⽅式有所不同。
> - binlog 是 MySQL 记录所有的操作，⽽ redolog 则是⽤于保证数据的⼀致性和持久性。此外，binlog 是逻辑⽇志，redolog 是物理⽇志。binlog 记录的是SQL语句，⽽ redolog 记录的是数据⻚的修改，所以 binlog 可以跨平台使⽤，⽽ redolog 不能。undolog 和redolog 的区别是，undolog 是⽤于回滚操作的，⽽ redolog 是⽤于恢复数据的。

​	

binlog：即存档⽇志，是 Server 层⽣成的的⽇志，主要⽤于数据备份和主从复制；



redolog：即重做⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现原⼦性和⼀致性的重要保证，主要⽤于事务回归和 MVCC；



uodolog：即回滚⽇志，是 Innodb 存储引擎层的⽇志，是 Mysql 实现持久性的重要保证，主要⽤于数据库事故故障恢复；



下⾯我们详细说说三种⽇志：

⾸先当我们执⾏⼀条增删改 sql 语句（没⽤begin）时，mysql 会隐式开启事务执⾏该条语句，在执⾏完毕后 mysql 会⾃动提交事务，我们就能看⻅增删改的实际结果，但是如果在事务执⾏中，mysql 在没提交事务的时候崩溃了，那么数据有问题了，此时就需要回滚到事务之前的数据，它本质就是⽤于撤销回退的⽇志（ctrl+z），在事务没提交之前，mysql 会记录更新前的数据到 undolog 中，当事务回滚时，就利⽤ uodolog ⽇志进⾏回滚：

在**插⼊**⼀条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值

对应的记录删掉；

在**删除**⼀条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录插⼊到表中；在**更新**⼀条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列更新为旧值。

⼀条记录的 uodolog 格式由 trx_ 事务 id + roll_pointer 指针串成⼀个链表，即**版本链**。此外**在**

**读提交和可重复读隔离级别中，它和快照** **readView** **实现了** **MVCC**。

然后是 redolog，它是为了防⽌机器故障导致数据丢失的物理⽇志，它⽤于记录数据⻚做了什

么修改，每当执⾏⼀条事务就会产⽣这样的⼀条或多条物理⽇志，然后通过**顺序写**写⼊磁盘。

它和 uodolog 区别是：**redolog** **记录了此次事务完成后的数据状态，记录的是更新之后的**

**值；****undolog** **记录了此次事务开始前的数据状态，记录的是更新之前的值；**它保证了数据的

持久性。

binlog 是逻辑⽇志，在完成⼀条更新操作后，server 层会⽣成 binlog，等事务提交时，将此事

务运⾏中产⽣的所有 DDL 记录通过追加写统⼀写⼊ binlog ⽇志⽂件，保存的是全量的⽇志，

⽤于备份恢复和主从复制。



### 介绍一下MVCC

全称 Multi-Version Concurrency Control ，多版本并发控制。MVCC的具体实现主要依赖于数据库记录中的**隐藏字段、undo log日志、readView**。

![image-20230527141103024](D:\笔记Md\picture\image-20230527141103024.png)





------



### 3.数据库索引是什么？有什么作用？什么场景适合使用索引？

**官方解析**

> 数据库索引是一种数据结构，用于提高数据库表的查询效率.
>
> 索引可以帮助数据库快速定位和检索存储在表中的数据，从⽽加快数据查询的速度。在数据量⽐较⼤时，使⽤索引可以极⼤地提⾼数据检索的效率。
>
> 
>
> 索引的作⽤是通过构建⼀个额外的数据结构（B-tree、哈希表等）来加速数据的检索。它是在数据库表上创建的⼀种数据结构，它包含⼀些指向表中数据的指针，可以快速地定位到满⾜查询条件的数据⾏，从⽽提⾼查询效率。索引可以包含⼀个或多个列，可以使⽤单列索引、组合索引、全⽂索引等多种⽅式来创建。
>
> 适合使⽤索引的场景包括：
>
> - 频繁查询的列，如主键、外键等。
> - 经常作为查询条件的列，如 WHERE、ORDER BY、GROUP BY 等语句中的列。
> - 经常需要连接的列，如多表联合查询时的列。数据量较⼤的表，通过索引可以加快数据检索速度。
>
> 
>
> 索引的优点是可以提⾼数据库的查询速度，缩短数据检索的时间，提⾼系统的性能。但是索引也有⼀些缺点，包括：
>
> - 占⽤额外的存储空间，增加了存储成本。
> - 建⽴索引需要时间，增加了系统的开销。
> - 数据库的更新操作（增删改）会导致索引的重建，影响系统的性能。
> - 因此，需要根据实际情况进⾏索引的创建和使⽤，避免过度索引导致系统性能下降。



**注：这题如果能举例你⾃⼰是如何在项⽬中应⽤索引的（⽐如检索⽤户消息）、或者说什么情况下你没有选择⽤索引的（⽐如性别字段），会很加分**。



**个人理解：**

数据库索引是⼀种数据结构，就想书的⽬录⼀样，它可以帮助我们快速定位到想要的数据。

> **优点**
>
> - ​	可以提⾼数据检索的效率，降低数据库的IO成本，类似于书的⽬录。
> - ​	通过索引列对数据进⾏排序，降低数据排序的成本，降低了CPU的消耗。



> **缺点**
>
> - ​	需要占⽤物理空间，数量越⼤，占⽤空间越⼤；
> - ​	索引虽然会提⾼查询效率，但是会降低更新表的效率。⽐如每次对表进⾏增删改操作，
> - ​	MySQL不仅要保存数据，还有保存或者更新对应的索引⽂件。



索引不是万能钥匙，它也是根据场景来使⽤的

> **什么场景适合使⽤索引？**
>
> - 频繁使⽤的列，主键、外键。
> - 字段有唯⼀性限制的，⽐如商品编码，可以使⽤唯⼀索引。
> - 经常⽤于 WHERE 查询条件的字段，这样能够提⾼整个表的查询速度，如果查询条件不是⼀个字段，可以建⽴联合索引。
> - 经常⽤于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做⼀次排序了，因为我们都已经知道了建⽴索引之后在 B+Tree 中的记录都是排序好的。
>
> 还有⼀点要注意的是索引失效的场景，本来使⽤索引是为了加快检索速度的，⼀旦索引失效，不仅起不了作⽤还占⽤空间。



> **索引失效**
>
> - 使⽤函数、计算、类型转换  使⽤这些以后，索引中存的不是函数计算后的值，⾃然⽤不到索引
> - like %xxx %xxx%



> **不符合最左匹配原则**
>
> - or 只有⼀边⽤上了索引，也会导致索引失效
> - 联合索引的最左匹配原则，在遇到范围查询（\>、<、between、like 包括like '林%'这种）的时候，就会停⽌匹配



> **什么时候不适合创建索引？**
>
> - **WHERE** **条件，****GROUP BY****，****ORDER BY** **⾥⽤不到的字段**，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占⽤物理空间的。
> - **字段中存在⼤量重复数据**，不需要创建索引，⽐如性别字段，只有男⼥，如果数据库表中，男⼥的记录分布均匀，那么⽆论搜索哪个值都可能得到⼀半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有⼀个查询优化器，查询优化器发现某个值出现在表的数据⾏中的百分⽐很⾼的时候，它⼀般会忽略索引，进⾏全表扫描。
> - **表数据太少**的时候，不需要创建索引；
> - **经常更新**的字段不⽤创建索引，⽐如不要对电商项⽬的⽤户余额建⽴索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。



**创建索引**

在MySQL中，可以使用CREATE INDEX语句来创建索引。下面是创建索引的具体实例：

1. 创建单列索引

创建单列索引只需要指定要创建索引的列名即可，语法如下：

```
CREATE INDEX index_name ON table_name (column_name);
```

其中，index_name是索引的名称，table_name是要创建索引的表名，column_name是要创建索引的列名。

例如，创建一个名为idx_age的年龄索引，用于加速对用户表user的年龄列的查询，可以使用以下语句：

```
CREATE INDEX idx_age ON user (age);
```

2. 创建多列索引

创建多列索引需要指定多个列名，语法如下：

```
CREATE INDEX index_name ON table_name (column_name1, column_name2, ...);
```

例如，创建一个名为idx_name_age的索引，用于加速对用户表user的姓名和年龄列的查询，可以使用以下语句：

```
CREATE INDEX idx_name_age ON user (name, age);
```

3. 创建唯一索引

创建唯一索引可以保证索引列的唯一性，语法如下：

```
CREATE UNIQUE INDEX index_name ON table_name (column_name);
```

例如，创建一个名为idx_email的唯一索引，用于加速对用户表user的email列的查询，并保证email列的唯一性，可以使用以下语句：

```
CREATE UNIQUE INDEX idx_email ON user (email);
```

注意：在创建索引时，需要根据实际情况选择合适的索引类型和索引列，避免过度索引导致性能下降。



### 一条语句，怎么加索引比较好？

在为一条语句加索引时，需要考虑以下因素：

1. 选择合适的索引类型：根据查询条件的特点选择合适的索引类型，如B-tree索引、哈希索引等。

2. 索引列的顺序：多列索引的顺序要考虑到查询条件的顺序，将经常查询的列放在前面。

3. 索引列的数量：索引列的数量要尽量少，一般不超过3个，过多的索引列会导致索引失效。

4. 数据库表的大小：对于大表，加索引会增加写入的时间，因此需要根据实际情况进行权衡。

5. 查询的频率：如果查询的频率很低，那么加索引的收益会很小，不值得加索引。

6. 数据库的负载：在高并发的情况下，加索引会增加锁竞争的概率，从而影响并发性能。

因此，在为一条语句加索引时，需要综合考虑以上因素，选择合适的索引策略。如果不确定应该加哪些索引，可以使用数据库的查询优化工具来分析查询语句，找到性能瓶颈并进行优化。



### 什么情况下索引会失效

1.  **违反最左前缀原则** （不以最左边的索引进行查询或者跳跃索引进行查询）。
2.  范围查询右边的列，不能使用索引，即如果范围查询后还有查询条件，则该查询列不能被查询到。
3. **不要再索引列上进行运算操作**，索引将失效
4. 字符串不加单引号，造成索引失效（即**类型转换**）
5.  以 % 开头的 like 模糊查询，索引失效。



**索引下推**

索引下推（Index Condition Pushdown，ICP）是一种 MySQL 数据库优化技术，它可以在查询时利用索引来过滤数据，并且可以尽早地过滤掉不符合查询条件的记录，从而减少返回结果集所需的 I/O 操作，提升查询性能。

索引下推主要通过将非索引字段的过滤条件移动到索引扫描过程中来实现。传统的查询流程是先通过索引扫描找到符合条件的记录，再通过过滤器排除不符合条件的记录，最后返回结果集。而索引下推则是将非索引字段的过滤条件与索引扫描过程结合起来，即在索引扫描过程中就可以排除不符合条件的记录，减少 I/O 操作。

例如，假设存在一张名为 user 的表，其中有两个字段 id 和 age，并且创建了（id, age）的联合索引。如果需要查询 id>1000 且 age>18 的记录，传统查询方式是按照 id 的顺序进行扫描，找到 id>1000 的记录，然后再按照 age 的条件进行过滤。而在索引下推的方式中，则可以将 age>18 的过滤条件移动到索引扫描的过程中，只有当 age>18 时才会返回记录，并在这个过程中就已经过滤掉了不满足条件的记录。

索引下推可以在很大程度上提升 MySQL 数据库的性能，尤其是对于大量数据的查询操作。需要注意的是，在某些情况下索引下推可能会降低查询性能，因此需要根据实际情况进行评估和优化。



------

### SQL 优化

- 表的设计：使用合适的数据类型
- 索引优化：
- sql语句优化：避免使用 select* ；尽量避免索引失效的场景；如果有将多个查询结果合并到一个结果集中，尽量使用 union all ，因为和union相比，前者少了一次过滤查询，查询效率高；
- 主从复制，读写分离：
- **分库分表：**

------













### 表级锁和行级锁有什么区别？











### 















------





# Spring 等框架



### 1. 什么是 Spring 框架，使用其有什么好处？

**官方解析：**

Spring 是 一个开源的 Java 企业应用程序框架，它通过依赖注入（Dependecy Injection）和面向切面编程等技术为开发者提供了一个全面的编程和配置模式。它可以降低java 开发的复杂度，提供代码的可维护性和可测试性，使得开发者能够更专注于业务逻辑的实现。

Spring 被认为是一款**轻量级**的框架。虽然它提供了丰富的功能和强大的特性，但它的设计理念是以简洁性、可测试性和松散耦合性为核心的，它不强制使用过多的第三方库和辅助工具，只提供基本的框架和关键的特性。

> Spring框架的轻量级体现在以下方面：
>
> 1. Sring框架的核心容器非常小巧，包括BeanFactory和ApplicationContext等，只有很少量的核心特性。
> 2. Spring框架不依赖于其他的第三方框架和工具，通过灵活的配置可以集成多种技术和工具。
> 3. Spring框架提供的控制反转和面向切面编程技术，可以对代码进行松散耦合的设计和实现，提高了代码的可测试性，减少了代码之间的依赖关系。
> 4. Spring框架的模块化设计，使得开发者可以根据自身需求选择需要的功能和特性，减少开发者学习和使用的负担。

综上所述，Spring框架的轻量级设计和高度可扩展性，使其成为最流行的Java框架之一。

> 使用 Spring 的好处：

> - 依赖注入：将不同组件间的依赖关系交于 Spring 进行管理，来降低组件间的耦合度，方便后续的组件替换和维护。
> - 面向切面编程：
> - 提供多种技术整合方案：
> - 支持声明式事务管理：
> - 提供 IOC 容器：
> - 便于测试：



**个人理解：**

Spring 框架由多个模块组成，其中核心的模块是 Spring Framework，它提供了许多常用的工具和服务，例如 Spring MVC、Spring ORM、Spring JDBC、Spring Security等。另外，Spring 还有其他的项目和模块，例如 Spring Boot 、Spring Cloud等，可进一步扩展和增强框架的功能。

开发场景：

> - **Web 应⽤程序开发**：Spring 框架是最常⽤的 Java Web 应⽤程序框架之⼀，因此在 Web开发中⼴泛使⽤。使⽤ Spring 可以轻松地处理 Web 请求和响应，⽽且还提供了许多其他有⽤的功能，如事务管理、安全性、数据访问和集成等。
> - **ESTful API 开发**：Spring 提供了⼀种简单的⽅法来创建 RESTful API，并允许使⽤各种HTTP ⽅法处理请求。它还提供了许多⼯具来解析 JSON 数据、处理异常、执⾏身份验证等等。
> - **企业级应⽤程序开发**：Spring 的核⼼⽬标是使企业级应⽤程序开发更加容易和⾼效。它提供了⼀整套⼯具和框架，可以⼤⼤减少企业级应⽤程序的开发和维护成本。Spring 框架中包含了许多常⽤的设计模式和最佳实践，如依赖注⼊、⾯向切⾯编程、模板模式、单元测试等等。
> - **批处理应⽤程序开发**：Spring 提供了许多⽤于批处理应⽤程序开发的⼯具和框架，如Spring Batch、Spring Integration 和 Spring XD。Spring Batch 是⼀个强⼤的批处理框架，可⽤于处理⼤量数据，并提供了⼀整套⼯具来处理事务、处理异常、执⾏监控等等。Spring Integration 是⼀个企业集成框架，可⽤于将不同的系统和组件集成到⼀个统⼀的体系结构中。Spring XD 是⼀个分布式数据处理框架，可⽤于处理⼤数据流。
> - **移动应⽤程序开发**：Spring 提供了⼀些⽤于移动应⽤程序开发的⼯具和框架，如 SpringMobile 和 Spring for Android。Spring Mobile 可⽤于开发适⽤于移动设备的 Web 应⽤程序，并根据设备的特定属性提供不同的视图和功能。Spring for Android 则可⽤于开发Android 应⽤程序，并提供了⼀些有⽤的功能，如异步任务处理、远程调⽤和 Web 服务集成等等。



主要优点：

1. 方便解耦，集合开发：Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring 进行管理。
2. 方便集成各种优秀的框架：Spring 不排斥使用优秀的开源框架，其内部提供了对各种优秀框架的直接支持。
3. 降低 Java EE API 的使用难度：对一些难用的API 进行了封装，降低了使用的难度。
4. 方便程序的测试：支持 JUnit ，可通过注解方便的测试 Spring 程序。
5. AOP 编程的支持：
6. 声明式事务的支持：



------

### 2. Spring 的两大核心概念是什么？简单讲述一下你对它们的理解

Spring 框架的两⼤核⼼概念是控制反转（Inversion of Control，IoC）和⾯向切⾯编程（Aspect Oriented Programming，AOP）。



**控制反转**指的是将对象的创建和依赖注⼊由应⽤代码转移到了 Spring 容器中进⾏，即由Spring 容器负责创建对象和管理它们之间的依赖关系。这样，应⽤代码只需要关注业务逻辑的实现，⽽不需要关注对象的创建和管理，降低了应⽤代码的复杂度，提⾼了代码的可重⽤性和可维护性。

**⾯向切⾯编程**是指将与业务逻辑⽆关的代码（如⽇志、安全、事务等）从业务逻辑中剥离出来，以便于统⼀管理和维护。通过 AOP，我们可以将这些与业务逻辑⽆关的横切关注点（Cross-cutting Concerns）定义为切⾯（Aspect），并将它们织⼊到业务逻辑中，从⽽实现了业务逻辑与横切关注点的解耦。



这两个概念是 Spring 框架的核⼼，它们使得 Spring 框架具有了⾼度的可扩展性、灵活性和模块化，极⼤地提⾼了应⽤程序的开发效率和代码的可维护性。

补充：这题在回答的时候可以通过举⾃⼰做项⽬的例⼦，来表达使⽤这两个核⼼概念的好处，⽐如⽤ AOP 来实现全局统⼀登录校验，就不⽤在每个⽅法⾥单独校验了。



------

### Spirng 中的单例 Bean 是线程安全的吗

不是，Spring 中有一个 @Scope 注解，默认的值是 singletion ，单例的。因为一般在 Spring 的 bean 中都是**注入无状态的对象**，没有线程安全问题，如果在bean中定义了可修改的成员变量，要考虑线程安全问题，可以使用多例或者加锁来解决。

------

### Spring 中的事务是如何实现的

主要为 编程式事务和声明式事务两种事务管理方式。













### Spring 中bean的生命周期

![image-20230527202406948](D:\笔记Md\picture\image-20230527202406948.png)



------

### SpringMVC 的执行流程

![image-20230520204607118](D:\笔记Md\picture\image-20230520204607118.png)



![image-20230520210817380](D:\笔记Md\picture\image-20230520210817380.png)



------







------

### Spring、SrpingMVC、SpringBoot常见注解

![image-20230520220358447](D:\笔记Md\picture\image-20230520220358447.png)

![image-20230520220521272](D:\笔记Md\picture\image-20230520220521272.png)

![image-20230520220634673](D:\笔记Md\picture\image-20230520220634673.png)





------

### Mybatis 执行流程

![image-20230520221731247](D:\笔记Md\picture\image-20230520221731247.png)





------

### Mybatis 是否支持延迟加载？

支持，但默认没有开启

![image-20230520222645378](D:\笔记Md\picture\image-20230520222645378.png)



------



### Mybatis 的缓存

























































------



# 计算机网络



### DNS 域名解析



**DNS 域名解析，简单地说就是把域名翻译成 IP 地址。**

![image-20230505235802520](D:\笔记Md\picture\image-20230505235802520.png)

























------

# 其他



### 1. 线程安全的类有哪些？

1. java.util.concurrent包中的类：如ConcurrentHashMap、CopyOnWriteArrayList等。
2. java.lang.Object类及其子类：Java中的所有对象都是线程安全的，可以直接使用。
3. java.util.Collections工具类：如Collections.synchronizedMap()方法可以返回一个线程安全的Map实例。
4. java.util.concurrent包中的Lock和Condition接口：可以用来实现线程同步和互斥。





------

### 2. 常见的加密算法

加密算法是将明文转换为密文的数学方法，以保证数据的保密性。常见的加密算法有:

- 对称加密算法：使用相同的密钥进行加密和解密操作，优点是加密速度快，适用于数据传输等对速度要求较高的场景。缺点是密钥管理较困难，容易被攻击者获取密钥从而进行破解。

  ​	(1) DES (Data Encryption Standard) 

  

  ​	(2) 3DES (Triple Data Encryption Standard) 三重数据加密算法

  

  ​	(3) AES (Advanced Encryption Standard) 高级加密标准，目前常用的对称加密算法之一，提供强大的安全性和速度

​			     加密过程：首先生成一个随机的 128 位或 192（256） 位的密钥，然后用这个密钥对数据进行加密。加密过程使用的是 （CBC				 算法）

​				 解密过程：对称解密，使用相同的算法进行解密。



- 非对称加密

​		 加密和解密使用不同的密钥。

> 1.  RSA加密算法：RSA 是一种基于大数因子分解的公开密钥算法，公钥和私钥具有一一对应的关系，公钥用于加密，私钥用于解密。RSA算法被广泛应用在数字证书、电子商务、电子邮件、VPN等领域。
> 2. DH加密算法：DH是一种密钥交换协议，可以让两个用户安全地交换共享密钥，从而进行加密通信。DH算法主要应用于VPN、安全网关、安全路由器等领域。
> 3. ECC加密算法：ECC（Elliptic Curve Cryptography）椭圆曲线密码算法是一种基于椭圆曲线的算法，公钥和私钥都是一些点坐标，密钥更短，加密速度更快，被广泛应用于移动端加密和IoT等领域。



- 哈希加密算法

​       哈希加密算法是通过一定数学模型将任意长度的输入（也称为“消息”）映射为固定长度的输出（也称为“哈希值”、"摘要" 或 "指纹"），通常是一个固定长度的二进制串。哈希算法的主要特点是不可逆，即无法从哈希值计算出原始输入的数据。

常用的哈希加密算法包括MD5、SHA-1、SHA-2等。

> 1. MD5：MD5算法是最常见的哈希算法之一，最初由Ronald Rivest于1991年设计。MD5算法可将任意长度的消息压缩为128位，常用于密码加密和数字签名等领域，但由于其加密强度较弱，存在被攻击的风险。
> 2. SHA-1：SHA-1（Secure Hash Algorithm-1）是一种加密哈希算法，将任意长度的消息转换成160位的消息摘要，广泛使用于数字认证、电子商务、数字签名等领域。但由于其安全性被破解，目前已不再推荐使用。
> 3. SHA-2：SHA-2（Secure Hash Algorithm 2）是SHA-1的升级版，在SHA-1被攻破后，被广泛使用于数字证书、电子商务、VPN等领域。SHA-2算法采用不同的消息摘要长度，包括SHA-224、SHA-256、SHA-384、SHA-512等。

哈希加密算法常用于保证数据的完整性、验证数字签名、密码哈希等场景。由于哈希加密算法的不可逆性，使其对密码的猜解和撞库攻击具有一定的安全保障。但随着计算能力不断提升，破解哈希也越来越容易，因此在应用中还应与其他安全技术结合使用，以提高安全性。
